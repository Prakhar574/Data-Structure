// src/components/Assessment/AssessmentQuestions.tsx (adjust path if needed)
import React, { useState, useEffect, useMemo, useCallback, useRef } from "react"; // Added useRef
import { CountdownCircleTimer } from "react-countdown-circle-timer";
import CheckIcon from "../../../public/static/img/icon/ic-check.svg";
import Logo from "../../../public/static/img/logo.svg";
import { Link, useNavigate } from "react-router-dom";
import { useAppDispatch, useAppSelector } from "../../app/hooks";
import { fetchQuestions, selectQuestions, selectQuestionsLoading, selectQuestionsError } from "../../features/questionSlice";
import {
    startTest,
    recordAnswer,
    markQuestionSkipped,
    // moveToNextQuestion, // Less relevant now?
    goToQuestion,
    submitTest,
    resetTest,
    selectCurrentQuestionIndex,
    selectQuestionStatuses,
    // selectActiveQuestionStartTime, // Removed
    selectIsQuestionLocked,
    // selectIsLastAvailableQuestion, // Logic may change
    selectSubmitLoading,
    selectAnswers,
    selectQuestionStatus,
    selectQuestionExpiryTime, // New selector
    selectAllQuestionIds, // Need all IDs for timer check
    selectIsTestSubmitted, // To stop timers
    selectAreAnyTimersActive, // Check if any timer is running
    selectCanSubmitTest, // Check if submission is allowed
} from "../../features/testSlice";
import { RootState } from "../../app/store";

const AssessmentQuestions = () => {
    const dispatch = useAppDispatch();
    const navigate = useNavigate();
    const intervalRef = useRef<NodeJS.Timeout | null>(null); // Ref to hold interval ID

    // --- Selectors ---
    const questions = useAppSelector(selectQuestions);
    const loadingQuestions = useAppSelector(selectQuestionsLoading);
    const errorQuestions = useAppSelector(selectQuestionsError);
    const currentQuestionIndex = useAppSelector(selectCurrentQuestionIndex);
    const questionStatuses = useAppSelector(selectQuestionStatuses);
    const allAnswers = useAppSelector(selectAnswers);
    const allQuestionIds = useAppSelector(selectAllQuestionIds);
    const isSubmitting = useAppSelector(selectSubmitLoading);
    const isTestSubmitted = useAppSelector(selectIsTestSubmitted);
    // We need the whole expiry times map for the background check
    const allExpiryTimes = useAppSelector((state: RootState) => state.test.questionExpiryTimes);
    const areAnyTimersActive = useAppSelector(selectAreAnyTimersActive);
    // const canSubmitTest = useAppSelector(selectCanSubmitTest); // Use if needed for submit button logic

    const [selectedOption, setSelectedOption] = useState<number | null>(null);
    // Timer key might still be useful for forcing visual refresh of CountdownCircleTimer
    const [timerKey, setTimerKey] = useState<number>(0);

    // --- Memoized Values ---
    const currentQuestion = useMemo(() => {
        // ... (no change)
        if (currentQuestionIndex >= 0 && currentQuestionIndex < questions.length) {
            return questions[currentQuestionIndex];
        }
        return null;
    }, [currentQuestionIndex, questions]);
    const currentQuestionId = useMemo(() => currentQuestion?._id, [currentQuestion]);
    const currentQuestionStatus = useAppSelector(state => currentQuestionId ? selectQuestionStatus(state, currentQuestionId) : 'pending');
    const currentQuestionExpiryTime = useAppSelector(state => currentQuestionId ? selectQuestionExpiryTime(state, currentQuestionId) : null);
    const isCurrentQuestionLocked = currentQuestionStatus === 'answered' || currentQuestionStatus === 'skipped';
    const isCurrentQuestionActive = currentQuestionStatus === 'active';


    // --- Effects ---

    // Fetch questions
    useEffect(() => { /* ... (no change) ... */ dispatch(fetchQuestions()); }, [dispatch]);

    // Start test
    useEffect(() => { /* ... (no change) ... */ if (questions.length > 0) dispatch(startTest({ questions })); }, [dispatch, questions]);

// *** NEW: Background Timer Check Effect ***
useEffect(() => {
    const checkTimers = () => {
        if (isTestSubmitted) { // Stop checking if test is submitted
            if (intervalRef.current) clearInterval(intervalRef.current);
            return;
        }

        const now = Date.now();
        Object.entries(allExpiryTimes).forEach(([qId, expiryTime]) => {
            if (expiryTime !== null && now >= expiryTime && questionStatuses[qId] === 'active') {
                console.log(`Timer expired for ${qId}. Auto-submitting selected answer (if any) and proceeding.`);

                // Auto-submit the currently selected option if one exists
                if (currentQuestionId === qId && selectedOption !== null) {
                    dispatch(recordAnswer({ questionId: qId, selectedOption }));
                } else {
                    // If no option was selected, mark as skipped
                    dispatch(markQuestionSkipped({ questionId: qId }));
                }

                // Check if it was the last question
                const lastQuestionId = allQuestionIds[allQuestionIds.length - 1];
                if (qId === lastQuestionId) {
                    console.log("Timer expired on the last question. Auto-submitting test.");
                    dispatch(submitTest()).unwrap().then(() => navigate("/completed")).catch(console.error);
                } else {
                    // Navigate to the next pending question
                    const expiredIndex = allQuestionIds.indexOf(qId);
                    const nextPendingIndex = allQuestionIds.findIndex((id, idx) => idx > expiredIndex && questionStatuses[id] === 'pending');
                    if (nextPendingIndex !== -1) {
                        dispatch(goToQuestion({ index: nextPendingIndex, questionId: allQuestionIds[nextPendingIndex] }));
                    } else {
                        // If no pending after, maybe go to the first pending?
                        const firstPendingIndex = allQuestionIds.findIndex(id => questionStatuses[id] === 'pending');
                        if (firstPendingIndex !== -1) {
                            dispatch(goToQuestion({ index: firstPendingIndex, questionId: allQuestionIds[firstPendingIndex] }));
                        }
                        // If no pending at all, maybe do nothing.
                    }
                }
            }
        });
    };

    // Clear any existing interval before starting a new one
    if (intervalRef.current) {
        clearInterval(intervalRef.current);
    }

    // Start interval only if there are questions and the test isn't submitted
    if (questions.length > 0 && !isTestSubmitted) {
        intervalRef.current = setInterval(checkTimers, 1000); // Check every second
        console.log("Background timer check started.");
    }


    // Cleanup function to clear interval on component unmount or when test is submitted
    return () => {
        if (intervalRef.current) {
            clearInterval(intervalRef.current);
            console.log("Background timer check stopped.");
        }
    };
    // Dependencies: Include everything needed inside checkTimers or that triggers interval restart
}, [allExpiryTimes, questionStatuses, dispatch, questions.length, isTestSubmitted, allQuestionIds, currentQuestionId, selectedOption, navigate]); // Added navigate as a dependency

    // Update local state (selectedOption) when viewing different questions
    useEffect(() => {
        if (currentQuestionId) {
            const status = questionStatuses[currentQuestionId];
            if (status === 'answered') {
                const recordedAnswer = allAnswers[currentQuestionId];
                setSelectedOption(recordedAnswer?.selectedOption ?? null);
            } else { // active, pending, or skipped
                setSelectedOption(null);
            }
        } else {
            setSelectedOption(null);
        }
        // Force visual timer refresh if navigating TO an active question
        if (questionStatuses[currentQuestionId!] === 'active') {
            setTimerKey(prev => prev + 1);
        }

    }, [currentQuestionIndex, currentQuestionId, questionStatuses, allAnswers]); // Keep dependencies


    // --- Callbacks ---

    // handleTimerComplete is removed from CountdownCircleTimer - background effect handles expiry

    const handleOptionClick = (index: number) => {
        if (isCurrentQuestionActive) setSelectedOption(index);
    };

    // Navigation click from list
    const handleGoToQuestion = (index: number, questionId: string) => {
        if (index !== currentQuestionIndex) {
            dispatch(goToQuestion({ index, questionId }));
        }
    };

    // *** UPDATED: Next/Submit Button Logic ***
    // Let's simplify: Remove the combined Next/Submit button for now.
    // Add a dedicated "Submit Test" button, maybe in the sidebar?
    // Or, the action button below the question only handles the *current* question.

    // Action for the button below the *current* question (only visible if active)
    const handleAnswerOrSkipCurrent = () => {
        if (!currentQuestionId || !isCurrentQuestionActive || isSubmitting) return;

        if (selectedOption !== null) {
            dispatch(recordAnswer({ questionId: currentQuestionId, selectedOption }));
        } else {
            // Treat clicking button without selection as explicit skip
            dispatch(markQuestionSkipped({ questionId: currentQuestionId }));
        }
        // Decide what happens next? Maybe navigate to next pending? Or just stay?
        // With free navigation, maybe just locking the current one is enough.
        // Let's find the *next* pending question's index to potentially navigate to.
        const nextPendingIndex = allQuestionIds.findIndex((id, idx) => idx > currentQuestionIndex && questionStatuses[id] === 'pending');
        if (nextPendingIndex !== -1) {
             dispatch(goToQuestion({ index: nextPendingIndex, questionId: allQuestionIds[nextPendingIndex] }));
        } else {
             // No more pending questions after this one. Maybe focus first incomplete?
             // Or just stay put. Let's stay put for simplicity for now.
        }
    };

     // Dedicated Submit function (e.g., for a separate button)
     const handleForceSubmit = () => {
         if (!isSubmitting) {
             dispatch(submitTest()).unwrap().then(() => navigate("/completed")).catch(console.error);
         }
     }


    // --- Render Logic ---

    if (loadingQuestions) return <div className="container vh-100 d-flex justify-content-center align-items-center">Loading questions...</div>;
    if (errorQuestions) return <div className="container vh-100 d-flex justify-content-center align-items-center">Error loading questions: {errorQuestions}</div>;
    if (!currentQuestion) return <div className="container vh-100 d-flex justify-content-center align-items-center">Loading assessment state...</div>;

    // Calculate remaining time for the *visible* timer if needed
    const remainingTimeForVisibleTimer = isCurrentQuestionActive && currentQuestionExpiryTime
        ? Math.max(0, Math.floor((currentQuestionExpiryTime - Date.now()) / 1000))
        : 0;


    return (
        <>
            <section className="container-fluid min-vh-100 d-flex align-items-center justify-content-center screen-bg">
                <div className="max-w-xxl mx-auto my-sm-5 my-4 px-3 w-100">
                    <Link to={"/"} className="d-flex align-items-center justify-content-center mb-3 w-fit mx-auto"> <img src={Logo} alt="Logo" className="img-fluid logo" /> </Link>
                    <div className="row bg-white py-5 px-sm-4 px-3 rounded-4 box-shadow lightgray-border">
                        {/* Main Question Area */}
                        <div className="col-lg-9 order-2 order-lg-1">
                            <h3 className="fs-20 fw-bold d-flex align-items-start gap-2 mb-4">
                                <span>Q{currentQuestionIndex + 1}.</span> {currentQuestion.question}
                                {currentQuestionStatus === 'skipped' && <span className="badge bg-warning text-dark ms-2">Skipped</span>}
                                {currentQuestionStatus === 'answered' && <span className="badge bg-success text-white ms-2">Answered</span>}
                                {isCurrentQuestionActive && <span className="badge bg-primary text-white ms-2">Active</span>}
                            </h3>

                            <ul className="ps-0 list-unstyled">
                                {currentQuestion.options.map((option, index) => {
                                    // ... (Option rendering logic - largely same as previous version)
                                     const isSelected = selectedOption === index;
                                    let optionClass = `fs-18 lightgray-border rounded-3 p-3 d-flex align-items-start justify-content-between gap-3 mb-3 options`;
                                    let interactionStyle = { cursor: 'not-allowed' }; // Default to not allowed

                                    if (isCurrentQuestionActive) {
                                        optionClass += ' cursor-pointer';
                                        interactionStyle = { cursor: 'pointer' };
                                         if (isSelected) optionClass += ' active';
                                    } else { // locked or pending
                                        optionClass += ' locked';
                                        if (isSelected) optionClass += ' active'; // Show recorded answer if locked&selected
                                    }
                                     return ( <li key={index} className={optionClass} onClick={() => handleOptionClick(index)} style={interactionStyle} > {/* ... content ... */}  <div className="d-flex align-items-start gap-3"> <div className={`fw-medium rounded-1 answer-option ${isSelected ? 'active' : ''}`}> {String.fromCharCode(65 + index)} </div> {option} </div> {isSelected && ( <img src={CheckIcon} alt="Selected Answer" width={24} className="align-self-center" /> )} </li> );
                                })}
                            </ul>

                            {/* *** UPDATED: Button only confirms current answer/skip *** */}
                            {isCurrentQuestionActive && (
                                <button
                                    type="button"
                                    className="btn primary-btn text-white w-fit mt-4 fw-semibold px-5"
                                    onClick={handleAnswerOrSkipCurrent}
                                    disabled={isSubmitting || selectedOption === null} // Disable if no selection
                                    title={selectedOption === null ? "Select an option to confirm" : "Confirm Answer / Skip"}
                                >
                                    {selectedOption !== null ? "Confirm Answer" : "Skip Question"}
                                </button>
                            )}
                            {/* Display message if locked */}
                             {isCurrentQuestionLocked && (
                                <p className="mt-4 text-muted">This question is locked.</p>
                             )}
                        </div>

                        {/* Sidebar Area */}
                        <div className="col-lg-3 order-1 order-lg-2 mb-lg-0 mb-4">
                            {/* Visible Timer (only for active question) */}
                            {isCurrentQuestionActive && currentQuestionExpiryTime && (
                                <div className="d-flex flex-column align-items-center justify-content-center gap-3 lightgray-border p-3 box-shadow rounded-3 mb-3">
                                    <div className="fs-2 primary-color fw-bold">
                                        <CountdownCircleTimer
                                            // *** UPDATED Key and Duration ***
                                            key={`timer-${currentQuestionId}-${timerKey}`}
                                            isPlaying={true} // Always playing visually if rendered
                                            duration={remainingTimeForVisibleTimer}
                                            initialRemainingTime={remainingTimeForVisibleTimer} // Start from calculated remaining
                                            colors={["#3919EE", "#8875F5", "#B0A3F8"]}
                                            colorsTime={[60, 30, 10]} // These might need adjustment based on duration now
                                            trailColor="#EAECF0"
                                            isSmoothColorTransition
                                            size={125}
                                            strokeWidth={9}
                                            // onComplete removed - background effect handles expiry
                                        >
                                            {({ remainingTime }) => remainingTime}
                                        </CountdownCircleTimer>
                                    </div>
                                    <h6 className="fw-bold mb-0">Time Left</h6>
                                </div>
                            )}
                             {/* Placeholder if current question is locked */}
                             {isCurrentQuestionLocked && (
                                 <div className="d-flex flex-column align-items-center justify-content-center gap-3 lightgray-border p-3 box-shadow rounded-3 mb-3">
                                      <div style={{ height: '130px', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
                                        <span className="text-muted">Timer N/A</span>
                                      </div>
                                      <h6 className="fw-bold mb-0">Question Locked</h6>
                                 </div>
                             )}


                            {/* Questions List (Navigation logic updated) */}
                            <div className="accordion" id="allQuestions">
                                <div className="accordion-item lightgray-border rounded-3 p-3 bg-white box-shadow">
                                    <h2 className="accordion-header"> <button className="accordion-button shadow-none bg-transparent fs-18 fw-bold p-0" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne"> Questions List </button> </h2>
                                    <div id="collapseOne" className="accordion-collapse collapse show" data-bs-parent="#allQuestions">
                                        <div className="accordion-body p-0 mt-3 pt-3 lightgray-border-t test">
                                            {questions.map((item, index) => {
                                                // ... (List item rendering logic - largely same as previous, but onClick always enabled)
                                                const qId = item._id;
                                                const status = questionStatuses[qId] || 'pending';
                                                const isLocked = status === 'answered' || status === 'skipped';
                                                const isAnswered = status === 'answered';
                                                const isActive = status === 'active';
                                                const isCurrent = index === currentQuestionIndex;
                                                let itemClass = `lightgray-border rounded-3 p-2 fs-14 fw-semibold d-flex align-items-center gap-3 justify-content-between mb-2 cursor-pointer`;
                                                if(isLocked) itemClass += isAnswered ? ' answered' : ' skipped';
                                                if(isActive) itemClass += ' active-question'; else if (status === 'pending') itemClass += ' pending-question';
                                                if(isCurrent) itemClass += ' current';
                                                return ( <div key={qId} className={itemClass} onClick={() => handleGoToQuestion(index, qId)} style={{ cursor: 'pointer' }} > <span className="question-number">Question {index + 1}</span> {/* Icons */} {isAnswered && <img src={CheckIcon} alt="Answered" width={14} />} {status === 'skipped' && <span title="Skipped" className="text-warning" style={{ fontSize: '10px', fontWeight:'bold' }}>S</span>} {isActive && <span title="Active Timer" className="spinner-grow spinner-grow-sm text-primary" role="status" aria-hidden="true" style={{width:'0.6rem', height:'0.6rem'}}></span>} </div> );
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* *** Optional Dedicated Submit Button *** */}
                            <div className="mt-3 d-grid">
                                <button
                                    className={`btn btn-danger ${!areAnyTimersActive ? 'btn-success' : ''}`} // Change color when all timers done
                                    onClick={handleForceSubmit}
                                    disabled={isSubmitting || isTestSubmitted}
                                    title={areAnyTimersActive ? "Submit test even with active timers" : "Submit Test"}
                                >
                                    {isSubmitting ? "Submitting..." : "Submit Test"}
                                </button>
                                {areAnyTimersActive && <small className="text-muted text-center mt-1">Timers are still running.</small>}
                            </div>

                        </div>
                    </div>
                </div>
            </section>
        </>
    );
};

export default AssessmentQuestions;



// src/features/testSlice.ts
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { Answers, TestResult, Questions } from '../types/questionstypes';
import { RootState } from '../app/store';
import axios from 'axios';
const API_URL = import.meta.env.VITE_BACKEND_URL as string;

type AnswerDetail = { selectedOption: number; submittedAt: string; timeTaken: number };
type QuestionStatus = 'pending' | 'active' | 'answered' | 'skipped';

interface TestState {
    currentQuestionIndex: number;
    answers: { [questionId: string]: AnswerDetail | null }; // Stores final answer/null for skipped
    questionStatuses: { [questionId: string]: QuestionStatus }; // Tracks the current state of each Q
    // *** NEW: Track expiry timestamp for each active question ***
    questionExpiryTimes: { [questionId: string]: number | null }; // Stores Date.now() + duration when Q becomes active
    questionStartTimes: { [questionId: string]: number | null }; // Store Date.now() when Q becomes active (for timeTaken calc)
    startTime: string | null;
    endTime: string | null;
    submitLoading: boolean;
    submitError: string | null;
    results: TestResult | null;
    allQuestionIds: string[];
    isTestSubmitted: boolean; // Flag to stop background timers after submission
}

const QUESTION_DURATION_MS = 60 * 1000; // 60 seconds in milliseconds

const initialState: TestState = {
    currentQuestionIndex: 0,
    answers: {},
    questionStatuses: {},
    questionExpiryTimes: {},
    questionStartTimes: {}, // Initialize
    startTime: null,
    endTime: null,
    submitLoading: false,
    submitError: null,
    results: null,
    allQuestionIds: [],
    isTestSubmitted: false,
};

const findNextAvailableIndex = (currentIndex: number, statuses: { [id: string]: QuestionStatus }, allIds: string[]): number => {
    const startIndex = (currentIndex + 1) % allIds.length;
    for (let i = startIndex; i !== currentIndex; i = (i + 1) % allIds.length) {
        if (statuses[allIds[i]] === 'pending') {
            return i;
        }
    }
    if (statuses[allIds[currentIndex]] === 'pending') {
        return currentIndex;
    }
    return -1;
};

export const submitTest = createAsyncThunk(
    'test/submit',
    async (_, { getState, rejectWithValue }) => {
        try {
            const { auth, test } = getState() as RootState;
            const token = auth.token;
            const answersArray: Answers[] = Object.entries(test.answers)
                .filter(([, answer]) => answer !== null)
                .map(([questionId, answer]) => ({
                    questionId,
                    selectedOption: (answer as any).selectedOption,
                    submittedAt: (answer as any).submittedAt,
                    timeTaken: (answer as any).timeTaken,
                }));

            const response = await axios.post(
                `${API_URL}/api/ques/submit/questions`,
                {
                    answers: answersArray,
                    startTime: test.startTime ? new Date(test.startTime).toISOString() : null,
                },
                {
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                }
            );
            return response.data;
        } catch (error: any) {
            return rejectWithValue(error.response.data.message || 'Failed to submit answers');
        }
    }
);


const testSlice = createSlice({
    name: 'test',
    initialState,
    reducers: {
        startTest: (state, action: PayloadAction<{ questions: Questions[] }>) => {
            const questionIds = action.payload.questions.map(q => q._id);
            const now = Date.now();
            state.allQuestionIds = questionIds;
            state.currentQuestionIndex = 0;
            state.answers = {};
            state.startTime = new Date(now).toISOString();
            state.endTime = null;
            state.results = null;
            state.submitError = null;
            state.submitLoading = false;
            state.isTestSubmitted = false; // Reset submitted flag

            // Initialize statuses, expiry times, and start times
            state.questionStatuses = {};
            state.questionExpiryTimes = {};
            state.questionStartTimes = {};
            questionIds.forEach((id, index) => {
                const isActive = index === 0;
                state.questionStatuses[id] = isActive ? 'active' : 'pending';
                state.questionExpiryTimes[id] = isActive ? now + QUESTION_DURATION_MS : null;
                state.questionStartTimes[id] = isActive ? now : null; // Record start time only when active
            });
        },

        // *** UPDATED goToQuestion: Handles activation and navigation ***
        goToQuestion: (state, action: PayloadAction<{ index: number; questionId: string }>) => {
            const { index, questionId } = action.payload;
            const targetStatus = state.questionStatuses[questionId];

            // Always allow changing the viewed question index
            state.currentQuestionIndex = index;

            // If navigating TO a PENDING question, make it active and start its timer.
            if (targetStatus === 'pending') {
                const now = Date.now();
                state.questionStatuses[questionId] = 'active';
                state.questionExpiryTimes[questionId] = now + QUESTION_DURATION_MS;
                state.questionStartTimes[questionId] = now; // Record start time
            }
            // No changes needed to status or timers if navigating to already active, answered, or skipped.
        },

        // *** UPDATED recordAnswer: Clear expiry, calculate timeTaken ***
        recordAnswer: (state, action: PayloadAction<{ questionId: string; selectedOption: number }>) => {
            const { questionId, selectedOption } = action.payload;
            const currentStatus = state.questionStatuses[questionId];

            // Only record if the question was 'active' (even if timer expired just now)
            if (currentStatus === 'active') {
                const now = Date.now();
                const startTime = state.questionStartTimes[questionId];
                const timeTaken = startTime ? Math.max(0, Math.floor((now - startTime) / 1000)) : 0; // Calculate time taken

                state.answers[questionId] = {
                    selectedOption,
                    submittedAt: new Date(now).toISOString(),
                    timeTaken: timeTaken,
                };
                state.questionStatuses[questionId] = 'answered';
                state.questionExpiryTimes[questionId] = null; // Stop timer
                state.questionStartTimes[questionId] = null; // Clear start time too
            }
            // If status was already answered/skipped, do nothing.
        },

        // *** UPDATED markQuestionSkipped: Clear expiry ***
        // This can be triggered by background timer or explicit skip action
        markQuestionSkipped: (state, action: PayloadAction<{ questionId: string }>) => {
            const { questionId } = action.payload;
            const currentStatus = state.questionStatuses[questionId];

            // Only mark skipped if it was 'active'
            if (currentStatus === 'active') {
                state.answers[questionId] = null; // Ensure no answer recorded
                state.questionStatuses[questionId] = 'skipped';
                state.questionExpiryTimes[questionId] = null; // Stop timer tracking
                state.questionStartTimes[questionId] = null; // Clear start time
            }
        },

        resetTest: (state) => {
            Object.assign(state, initialState);
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(submitTest.pending, (state) => {
                state.submitLoading = true;
                state.submitError = null;
                state.endTime = null;
            })
            .addCase(submitTest.fulfilled, (state, action) => {
                state.submitLoading = false;
                state.endTime = new Date().toISOString();
                state.results = action.payload;
                state.isTestSubmitted = true; // Set flag to stop background timers
                // Clear expiry times to ensure timers stop
                state.questionExpiryTimes = {};
            })
            .addCase(submitTest.rejected, (state, action) => {
                state.submitLoading = false;
                state.submitError = action.payload as string;
                state.endTime = null;
                // Should we set isTestSubmitted = true even on failure? Depends on desired retry logic.
                // For now, let's assume submission failure means the test is still 'active'.
                // state.isTestSubmitted = true;
            });
    },
});

// --- Selectors ---
export const {
    startTest,
    goToQuestion,
    recordAnswer,
    markQuestionSkipped,
    resetTest,
} = testSlice.actions;

// Existing selectors remain mostly the same
export const selectCurrentQuestionIndex = (state: RootState) => state.test.currentQuestionIndex;
export const selectAllQuestionIds = (state: RootState) => state.test.allQuestionIds;
export const selectQuestionStatuses = (state: RootState) => state.test.questionStatuses;
export const selectAnswers = (state: RootState) => state.test.answers;
export const selectStartTime = (state: RootState) => state.test.startTime;
export const selectSubmitLoading = (state: RootState) => state.test.submitLoading;
export const selectSubmitError = (state: RootState) => state.test.submitError;
export const selectTestResults = (state: RootState) => state.test.results;
export const selectQuestionStatus = (state: RootState, questionId: string): QuestionStatus | undefined => state.test.questionStatuses[questionId];
export const selectIsQuestionLocked = (state: RootState, questionId: string): boolean => {
    // Logic for locking questions can be added here if needed, based on test flow.
    // For now, assuming no explicit locking.
    return false;
};
export const selectArePendingQuestionsLeft = (state: RootState): boolean => {
    return Object.values(state.test.questionStatuses).some(status => status === 'pending');
};
export const selectIsTestSubmitted = (state: RootState): boolean => state.test.isTestSubmitted;

// *** NEW Selector for expiry time ***
export const selectQuestionExpiryTime = (state: RootState, questionId: string): number | null => state.test.questionExpiryTimes[questionId] ?? null;


// Helper selector to check if *any* question timer is currently active
export const selectAreAnyTimersActive = (state: RootState): boolean => {
    return Object.values(state.test.questionExpiryTimes).some(time => time !== null);
}

// Selector to determine if the test can be submitted (e.g., all timers finished or all answered/skipped)
// This logic might be complex depending on exact requirements (allow submit anytime?)
export const selectCanSubmitTest = (state: RootState): boolean => {
    // Example: Allow submit only if no timers are active
    // return !Object.values(state.test.questionExpiryTimes).some(time => time !== null);
    // Or allow submit anytime? For now, let's assume submit is always an option via a dedicated button or last question logic.
    // Let's refine the logic for the "Submit" button visibility/action later.
    return true; // Placeholder: Assume submit is always an option now
}


export default testSlice.reducer;

// src/features/questionSlice.ts
// (Keep this file as it was in the prompt - no changes needed here)

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { Questions } from '../types/questionstypes'; // Ensure this type import is correct
import { RootState } from '../app/store'; // Ensure this path is correct
import axios from 'axios';
const API_URL = import.meta.env.VITE_BACKEND_URL as string;

interface QuestionState {
    questions: Questions[];
    loading: boolean;
    error: string | null;
}
const initialState: QuestionState = {
    questions: [],
    loading: false,
    error: null,
}

export const fetchQuestions = createAsyncThunk(
    'questions/fetch',
    async (_, { getState, rejectWithValue }) => {
        try {
            const { auth } = getState() as RootState; // Assuming auth slice exists and holds the token
            const token = auth?.token; // Make sure token exists
            if (!token) {
                return rejectWithValue('Authentication token not found.');
            }
            const response = await axios.get(`${API_URL}/api/ques/questions`, { // Ensure API endpoint is correct
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            return response.data;
        } catch (error: any) {
            return rejectWithValue(error.response?.data?.message || 'Failed to fetch questions');
        }
    }
);

const questionSlice = createSlice({
    name: 'questions',
    initialState,
    reducers: {}, // No synchronous reducers defined here
    extraReducers: (builder) => {
        builder
            .addCase(fetchQuestions.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(fetchQuestions.fulfilled, (state, action) => {
                state.loading = false;
                state.questions = action.payload; // Assuming payload is Questions[]
            })
            .addCase(fetchQuestions.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload as string;
            });
    },
});

// Selectors
export const selectQuestions = (state: RootState) => state.questions.questions; // Ensure RootState includes questions slice
export const selectQuestionsLoading = (state: RootState) => state.questions.loading;
export const selectQuestionsError = (state: RootState) => state.questions.error;

export default questionSlice.reducer;

