Of course! Let's integrate emoji reactions and a message reply feature, similar to WhatsApp, into the chat application we've been building.

This is a significant update, so we'll touch the database model, the backend socket service, and several frontend components.

‚ö†Ô∏è Prerequisite: Install New Package
First, navigate to your client directory and install the emoji picker package:

Bash

cd client
npm install emoji-picker-react
1. Backend Updates (Server)
We need to modify our database schema to store reactions and reply information.

server/src/models/Message.ts (Updated)
We'll add two new fields: reactions and replyTo.

TypeScript

import mongoose, { Document, Schema, Types } from 'mongoose';

// Interface for a reaction
export interface IReaction {
    emoji: string;
    user: Types.ObjectId | string;
}

// Interface for the original message preview in a reply
export interface IOriginalMessage {
    _id: Types.ObjectId | string;
    content: string;
    sender: { // Store basic sender info to avoid extra lookups
        _id: Types.ObjectId | string;
        username: string;
    };
}


export interface IMessage extends Document {
  sender: Types.ObjectId | { _id: string, username: string, avatar?: string };
  receiver: Types.ObjectId | { _id: string, username: string, avatar?: string };
  content: string;
  timestamp: Date;
  read: boolean;
  // --- NEW FIELDS ---
  reactions: IReaction[];
  replyTo?: IOriginalMessage; // Holds a reference to the message being replied to
}

const ReactionSchema: Schema = new Schema({
    emoji: { type: String, required: true },
    user: { type: Schema.Types.ObjectId, ref: 'User', required: true }
}, { _id: false }); // _id is not needed for sub-documents here

const OriginalMessageSchema: Schema = new Schema({
    _id: { type: Schema.Types.ObjectId, ref: 'Message', required: true },
    content: { type: String, required: true },
    sender: {
        _id: { type: Schema.Types.ObjectId, ref: 'User', required: true },
        username: { type: String, required: true },
    }
}, { _id: false });


const MessageSchema: Schema = new Schema({
  sender: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  receiver: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  content: { type: String, required: true },
  timestamp: { type: Date, default: Date.now },
  read: { type: Boolean, default: false },
  // --- NEW FIELDS ---
  reactions: [ReactionSchema],
  replyTo: { type: OriginalMessageSchema, required: false }
});

export default mongoose.model<IMessage>('Message', MessageSchema);
server/src/services/socketService.ts (Updated)
Now, let's update our Socket.IO service to handle sending replies and adding reactions.

TypeScript

import { Server as SocketIOServer, Socket } from 'socket.io';
import http from 'http';
import Message, { IMessage } from '../models/Message';
import User from '../models/User';
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';
import dotenv from 'dotenv';

dotenv.config();
const JWT_SECRET = process.env.JWT_SECRET || 'yourfallbacksecret';

interface UserSocketMap {
    [userId: string]: string; // userId: socketId
}

const userSockets: UserSocketMap = {};

export const initializeSocketIO = (httpServer: http.Server) => {
    const io = new SocketIOServer(httpServer, {
        cors: {
            origin: process.env.CLIENT_URL || "http://localhost:3000",
            methods: ["GET", "POST"],
        },
    });

    io.use(async (socket, next) => {
        // ... (Socket.IO auth middleware remains the same)
        const token = socket.handshake.auth.token;
        if (!token) {
            return next(new Error('Authentication error: Token not provided'));
        }
        try {
            const decoded = jwt.verify(token, JWT_SECRET) as { user: { id: string } };
            (socket as any).userId = decoded.user.id;
            next();
        } catch (err) {
            console.error("Socket auth error:", err);
            return next(new Error('Authentication error: Invalid token'));
        }
    });

    io.on('connection', async (socket: Socket) => {
        const userId = (socket as any).userId;
        console.log(`User connected: ${socket.id}, userId: ${userId}`);
        userSockets[userId] = socket.id;

        // ... (online/offline status logic remains the same)
        try {
            await User.findByIdAndUpdate(userId, { online: true });
            socket.broadcast.emit('userOnline', { userId });
        } catch (error) {
            console.error("Error updating user to online:", error);
        }


        // --- UPDATED: Handle incoming messages (with reply functionality) ---
        socket.on('sendMessage', async (data: { receiverId: string; content: string; replyTo?: string }) => {
            const { receiverId, content, replyTo } = data;
            const senderId = userId;

            try {
                let originalMessageInfo;
                if (replyTo) {
                    const originalMessage = await Message.findById(replyTo).populate('sender', 'username');
                    if (originalMessage) {
                         originalMessageInfo = {
                            _id: originalMessage._id,
                            content: originalMessage.content,
                            sender: {
                                _id: (originalMessage.sender as any)._id,
                                username: (originalMessage.sender as any).username,
                            }
                         };
                    }
                }

                const newMessage = new Message({
                    sender: senderId,
                    receiver: receiverId,
                    content: content,
                    replyTo: originalMessageInfo,
                });
                const savedMessage = await newMessage.save();
                const populatedMessage = await Message.findById(savedMessage._id)
                    .populate('sender', 'username avatar _id')
                    .populate('receiver', 'username avatar _id');

                const receiverSocketId = userSockets[receiverId];
                if (receiverSocketId) {
                    io.to(receiverSocketId).emit('receiveMessage', populatedMessage);
                }
                socket.emit('receiveMessage', populatedMessage);

            } catch (err) {
                console.error('Error saving or sending message:', err);
                socket.emit('messageError', { error: 'Failed to send message' });
            }
        });

        // --- NEW: Handle message reactions ---
        socket.on('reactToMessage', async (data: { messageId: string, emoji: string }) => {
            const { messageId, emoji } = data;
            const reactorId = userId;

            try {
                const message = await Message.findById(messageId);
                if (!message) return;

                // Find if the user has already reacted with any emoji
                const existingReactionIndex = message.reactions.findIndex(r => r.user.toString() === reactorId);

                if (existingReactionIndex > -1) {
                    // If reacting with the same emoji, remove reaction (toggle off)
                    if (message.reactions[existingReactionIndex].emoji === emoji) {
                         message.reactions.splice(existingReactionIndex, 1);
                    } else {
                        // If reacting with a different emoji, update it
                        message.reactions[existingReactionIndex].emoji = emoji;
                    }
                } else {
                    // If no existing reaction from this user, add a new one
                    message.reactions.push({ emoji, user: new mongoose.Types.ObjectId(reactorId) });
                }

                await message.save();
                const updatedMessage = await Message.findById(messageId)
                    .populate('sender', 'username avatar _id')
                    .populate('receiver', 'username avatar _id');

                // Broadcast the updated message to both sender and receiver
                const receiverSocketId = userSockets[message.receiver.toString()];
                const senderSocketId = userSockets[message.sender.toString()];

                if (receiverSocketId) {
                    io.to(receiverSocketId).emit('messageUpdated', updatedMessage);
                }
                if (senderSocketId) {
                    io.to(senderSocketId).emit('messageUpdated', updatedMessage);
                }

            } catch (error) {
                 console.error('Error reacting to message:', error);
                 socket.emit('messageError', { error: 'Failed to react to message' });
            }
        });

        // ... (typing indicator and disconnect logic remains the same)
        socket.on('disconnect', async () => {
             console.log(`User disconnected: ${socket.id}, userId: ${userId}`);
            delete userSockets[userId];
            try {
                await User.findByIdAndUpdate(userId, { online: false, lastSeen: new Date() });
                socket.broadcast.emit('userOffline', { userId });
            } catch (error) {
                console.error("Error updating user to offline:", error);
            }
        });
    });

    return io;
};
2. Frontend Updates (Client)
Now for the client-side changes. We'll update our Redux slice and the UI components.

client/src/features/messages/messagesSlice.ts (Updated)
We need to update the Message interface and add a new reducer to handle message updates (like new reactions).

TypeScript

import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import axios from 'axios';
import { RootState } from '../../app/store';

// --- NEW/UPDATED INTERFACES ---
interface Reaction {
    emoji: string;
    user: string; // User ID
}

interface OriginalMessage {
    _id: string;
    content: string;
    sender: {
        _id: string;
        username: string;
    };
}

export interface Message {
    _id: string;
    sender: { _id: string, username: string, avatar?: string };
    receiver: { _id: string, username: string, avatar?: string };
    content: string;
    timestamp: string;
    read: boolean;
    reactions: Reaction[];
    replyTo?: OriginalMessage;
}

interface MessagesState {
    messages: Message[];
    isLoading: boolean;
    error: string | null;
    typingUsers: { [userId: string]: boolean };
}

const initialState: MessagesState = {
    messages: [],
    isLoading: false,
    error: null,
    typingUsers: {},
};

export const fetchMessages = createAsyncThunk(
    // ... (fetchMessages thunk remains the same)
    'messages/fetchMessages',
    async (otherUserId: string, thunkAPI) => {
        const token = (thunkAPI.getState() as RootState).auth.token;
        try {
            const response = await axios.get(`http://localhost:5001/api/messages/${otherUserId}`, {
                headers: { 'x-auth-token': token },
            });
            return response.data as Message[];
        } catch (error: any) {
            const message = (error.response && error.response.data && error.response.data.msg) || error.message || error.toString();
            return thunkAPI.rejectWithValue(message);
        }
    }
);

const messagesSlice = createSlice({
    name: 'messages',
    initialState,
    reducers: {
        addMessage: (state, action: PayloadAction<Message>) => {
            if (!state.messages.find(msg => msg._id === action.payload._id)) {
                 state.messages.push(action.payload);
            }
        },
        // --- NEW REDUCER ---
        updateMessage: (state, action: PayloadAction<Message>) => {
            const index = state.messages.findIndex(msg => msg._id === action.payload._id);
            if (index !== -1) {
                state.messages[index] = action.payload;
            }
        },
        clearMessages: (state) => {
            state.messages = [];
        },
        // ... (setTyping and resetMessagesError remain the same)
    },
    extraReducers: (builder) => {
        // ... (extraReducers logic remains the same)
        builder
            .addCase(fetchMessages.pending, (state) => {
                state.isLoading = true;
            })
            .addCase(fetchMessages.fulfilled, (state, action: PayloadAction<Message[]>) => {
                state.isLoading = false;
                state.messages = action.payload;
            })
            .addCase(fetchMessages.rejected, (state, action) => {
                state.isLoading = false;
                state.error = action.payload as string;
            });
    },
});

// Export new action
export const { addMessage, updateMessage, clearMessages, setTyping, resetMessagesError } = messagesSlice.actions;
export default messagesSlice.reducer;
client/src/App.tsx (Updated)
Add the handler for the new messageUpdated socket event.

TypeScript

// ... (inside the AppContent component's main useEffect)
      // ...
      socketInstance.on('receiveMessage', (message) => {
          // ... (this logic remains the same)
      });

      // --- NEW SOCKET EVENT HANDLER ---
      socketInstance.on('messageUpdated', (updatedMessage) => {
          dispatch(updateMessage(updatedMessage));
      });

      socketInstance.on('userOnline', ({ userId }) => {
      // ...
// ... (and in the cleanup function)
      return () => {
        if (socketInstance) {
          console.log("Cleaning up socket listeners in App.tsx");
          socketInstance.off('receiveMessage');
          socketInstance.off('messageUpdated'); // <-- Add this
          socketInstance.off('userOnline');
          // ...
        }
      };
// ...
client/src/components/Chat/ChatWindow.tsx (Updated)
This component will now manage the state for which message is being replied to.

TypeScript

import React, { useEffect, useRef, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { Card, Form, Button, InputGroup, Image, Alert } from 'react-bootstrap';
import { RootState, AppDispatch } from '../../app/store';
import { Message } from '../../features/messages/messagesSlice';
import MessageItem from './MessageItem';
import { User as AuthUser } from '../../features/auth/authSlice';
import { User as SelectedUserType } from '../../features/users/usersSlice';
import { getSocket, sendTypingSocket } from '../../services/socket';
import { FaPaperPlane, FaTimes } from 'react-icons/fa';

interface ChatWindowProps {
    selectedUser: SelectedUserType;
    currentUser: AuthUser;
}

const ChatWindow: React.FC<ChatWindowProps> = ({ selectedUser, currentUser }) => {
    const dispatch = useDispatch<AppDispatch>();
    const { messages, isLoading, error } = useSelector((state: RootState) => state.messages);
    const [newMessage, setNewMessage] = useState('');
    // --- NEW STATE FOR REPLYING ---
    const [replyingToMessage, setReplyingToMessage] = useState<Message | null>(null);

    const messagesEndRef = useRef<HTMLDivElement>(null);
    // ...

    useEffect(() => {
        // Clear reply state when chat partner changes
        setReplyingToMessage(null);
    }, [selectedUser]);

    const handleSendMessage = (e: React.FormEvent) => {
        e.preventDefault();
        if (newMessage.trim() === '' || !selectedUser) return;

        const socket = getSocket();
        socket.emit('sendMessage', {
            receiverId: selectedUser._id,
            content: newMessage,
            replyTo: replyingToMessage?._id, // <-- Send reply info
        });

        setNewMessage('');
        setReplyingToMessage(null); // <-- Clear reply state after sending
        // ...
    };

    // --- NEW: Function to set the reply state, passed to MessageItem ---
    const handleSetReply = (message: Message) => {
        setReplyingToMessage(message);
    };

    // ...

    return (
        <div className="d-flex flex-column h-100">
            {/* ... (Card.Header remains the same) ... */}

            <Card.Body className="p-3 flex-grow-1" style={{ overflowY: 'auto', backgroundColor: '#f0f2f5' }}>
                {/* ... (Message mapping logic) ... */}
                {!isLoading && !error && messages.map((msg: Message) => (
                    <MessageItem
                        key={msg._id}
                        message={msg}
                        currentUserId={currentUser.id}
                        onReply={handleSetReply} // <-- Pass reply handler down
                    />
                ))}
                <div ref={messagesEndRef} />
            </Card.Body>

            <Card.Footer className="p-3 border-top">
                {/* --- NEW: Reply Preview --- */}
                {replyingToMessage && (
                    <Alert
                        variant="secondary"
                        onClose={() => setReplyingToMessage(null)}
                        dismissible
                        className="p-2 mb-2"
                    >
                        <Alert.Heading className="fs-6 mb-0">
                            Replying to {replyingToMessage.sender.username}
                        </Alert.Heading>
                        <p className="mb-0 text-muted" style={{
                            whiteSpace: 'nowrap',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis'
                        }}>
                            {replyingToMessage.content}
                        </p>
                    </Alert>
                )}
                {/* --- Form remains largely the same --- */}
                <Form onSubmit={handleSendMessage}>
                    {/* ... (InputGroup and Form.Control) ... */}
                </Form>
            </Card.Footer>
        </div>
    );
};

export default ChatWindow;
client/src/components/Chat/MessageItem.tsx (Heavily Updated)
This is where the main UI for replies and reactions will be implemented. This component becomes much more interactive.

TypeScript

import React, { useState } from 'react';
import { Message } from '../../features/messages/messagesSlice';
import { Image, Popover, OverlayTrigger, Button, Badge } from 'react-bootstrap';
import { FaReply, FaRegSmile } from 'react-icons/fa';
import EmojiPicker, { EmojiClickData } from 'emoji-picker-react';
import { getSocket } from '../../services/socket';
import './MessageItem.css'; // We'll update this file next

interface MessageItemProps {
    message: Message;
    currentUserId: string;
    onReply: (message: Message) => void; // Callback to initiate a reply
}

const MessageItem: React.FC<MessageItemProps> = ({ message, currentUserId, onReply }) => {
    const isSender = message.sender._id === currentUserId;
    const timeString = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const [showActions, setShowActions] = useState(false);

    const handleEmojiSelect = (emojiData: EmojiClickData) => {
        const socket = getSocket();
        socket.emit('reactToMessage', {
            messageId: message._id,
            emoji: emojiData.emoji,
        });
        // Close the popover manually by clicking the body
        document.body.click();
    };

    // Group reactions for display (e.g., üòÇ: 2, ‚ù§Ô∏è: 1)
    const groupedReactions = message.reactions.reduce((acc, reaction) => {
        acc[reaction.emoji] = (acc[reaction.emoji] || 0) + 1;
        return acc;
    }, {} as Record<string, number>);

    const emojiPickerPopover = (
        <Popover id={`popover-emoji-${message._id}`} style={{ border: 'none' }}>
            <Popover.Body style={{ padding: 0 }}>
                <EmojiPicker onEmojiClick={handleEmojiSelect} height={350} width={300} />
            </Popover.Body>
        </Popover>
    );

    return (
        <div
            className={`d-flex mb-1 message-container ${isSender ? 'justify-content-end' : 'justify-content-start'}`}
            onMouseEnter={() => setShowActions(true)}
            onMouseLeave={() => setShowActions(false)}
        >
            {/* Action Buttons (Reply, React) */}
            <div className={`message-actions ${isSender ? 'actions-left' : 'actions-right'}`}>
                {showActions && (
                    <>
                        <Button variant="link" size="sm" className="p-0 me-2 action-btn" onClick={() => onReply(message)}>
                            <FaReply />
                        </Button>
                        <OverlayTrigger trigger="click" placement={isSender ? "left" : "right"} overlay={emojiPickerPopover} rootClose>
                            <Button variant="link" size="sm" className="p-0 action-btn">
                                <FaRegSmile />
                            </Button>
                        </OverlayTrigger>
                    </>
                )}
            </div>

            {/* Message Bubble */}
            <div className={`message-bubble-wrapper ${isSender ? 'sent' : 'received'}`}>
                {/* --- NEW: Reply Block --- */}
                {message.replyTo && (
                    <div className="reply-preview p-2 mb-1">
                        <p className="fw-bold mb-0" style={{fontSize: '0.8rem'}}>{message.replyTo.sender.username}</p>
                        <p className="mb-0 text-muted" style={{fontSize: '0.9rem'}}>
                            {message.replyTo.content}
                        </p>
                    </div>
                )}

                <div className={`message-bubble p-2 px-3 shadow-sm`}>
                    {!isSender && <small className="fw-bold d-block message-sender-name">{message.sender.username}</small>}
                    <p className="mb-1 message-content">{message.content}</p>
                    <small className="text-muted d-block text-end message-timestamp">{timeString}</small>

                    {/* --- NEW: Reactions Display --- */}
                    {Object.keys(groupedReactions).length > 0 && (
                        <div className="reactions-container">
                            {Object.entries(groupedReactions).map(([emoji, count]) => (
                                <Badge pill bg="light" text="dark" key={emoji} className="reaction-badge">
                                    {emoji} {count > 1 && count}
                                </Badge>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default MessageItem;

client/src/components/Chat/MessageItem.css (Updated)
Finally, let's add styles for the new UI elements.

CSS

/* Container for the whole message row */
.message-container {
    position: relative;
    padding: 0 40px; /* Make space for action buttons */
}

/* Actions buttons (reply, react) */
.message-actions {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    align-items: center;
    background-color: #f8f9fa;
    border-radius: 20px;
    padding: 4px 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
}
.message-container:hover .message-actions {
    opacity: 1;
}
.actions-left { left: 0; }
.actions-right { right: 0; }
.action-btn {
    color: #6c757d;
    font-size: 1.1rem;
}
.action-btn:hover {
    color: #343a40;
}

/* Wrapper for the bubble and its contents */
.message-bubble-wrapper {
    max-width: 75%;
}

.message-bubble {
    border-radius: 15px;
    position: relative;
}

.message-bubble-wrapper.sent .message-bubble {
    background-color: #dcf8c6;
    border-bottom-right-radius: 5px;
    color: #303030;
}

.message-bubble-wrapper.received .message-bubble {
    background-color: #ffffff;
    border-bottom-left-radius: 5px;
    color: #303030;
    border: 1px solid #e9e9e9;
}

/* Reply preview styling */
.reply-preview {
    background-color: rgba(0, 0, 0, 0.05);
    border-left: 3px solid #0d6efd; /* Use theme primary color */
    border-radius: 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}
.message-bubble-wrapper.received .reply-preview {
    border-left-color: #6c757d; /* A different color for received replies */
}

/* Reactions styling */
.reactions-container {
    position: absolute;
    bottom: -10px;
    right: 10px; /* Adjust for sent vs received */
    background-color: #fff;
    border-radius: 10px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    padding: 2px 4px;
    display: flex;
    gap: 2px;
}
.message-bubble-wrapper.received .reactions-container {
    left: 10px;
    right: auto;
}
.reaction-badge {
    font-size: 0.8rem;
    cursor: pointer;
}

/* Other styles from before... */
.message-sender-name { /* ... */ }
.message-content { /* ... */ }
.message-timestamp { /* ... */ }
